{
  "version": 3,
  "sources": ["../../src/index.ts", "../../src/base64url.ts", "../../src/compress.ts"],
  "sourcesContent": ["import { encodeBase64Url, decodeBase64Url } from './base64url.js'\nimport {\n  compress,\n  decompressAsString,\n  decompressAsArrayBuffer,\n  CompressionFormat,\n} from './compress.js'\n\nexport type { CompressionFormat }\n\nexport async function encode(value: any, compressionFormat?: CompressionFormat): Promise<string> {\n  return encodeBase64Url(await compress(JSON.stringify(value), compressionFormat))\n}\n\nexport async function decode(text: string, compressionFormat?: CompressionFormat): Promise<any> {\n  return JSON.parse(await decompressAsString(decodeBase64Url(text), compressionFormat))\n}\n\nexport async function encodeBinary(value: ArrayBuffer, compressionFormat?: CompressionFormat): Promise<string> {\n  return encodeBase64Url(await compress(value, compressionFormat))\n}\n\nexport async function decodeBinary(text: string, compressionFormat?: CompressionFormat): Promise<ArrayBuffer> {\n  return await decompressAsArrayBuffer(decodeBase64Url(text), compressionFormat)\n}\n", "/**\n * Base64 URL: Base64 encoding with URL-safe character set\n *\n * TODO: Replace with atob/btoa?\n *\n * https://developer.mozilla.org/en-US/docs/Glossary/Base64#the_unicode_problem\n *\n * - Replace `+` with `-`\n * - Replace `/` with `_`\n * - Replace padding `=` with `~`\n */\n\nconst chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'\n\nexport function encodeBase64Url(arraybuffer: ArrayBuffer): string {\n  const bytes = new Uint8Array(arraybuffer)\n  const len = bytes.length\n  let base64 = ''\n\n  for (let i = 0; i < len; i += 3) {\n    base64 += chars[bytes[i] >> 2]\n    base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)]\n    base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)]\n    base64 += chars[bytes[i + 2] & 63]\n  }\n\n  if (len % 3 === 2) {\n    base64 = base64.substring(0, base64.length - 1) + '~'\n  } else if (len % 3 === 1) {\n    base64 = base64.substring(0, base64.length - 2) + '~~'\n  }\n\n  return base64\n}\n\nlet lookup: Uint8Array | undefined\n\nexport function decodeBase64Url(base64: string): ArrayBuffer {\n  // Create lookup table to find the index\n  if (!lookup) {\n    lookup = new Uint8Array(256)\n    for (let i = 0; i < chars.length; i++) {\n      lookup[chars.charCodeAt(i)] = i\n    }\n  }\n\n  const len: number = base64.length\n  let bufferLength: number = (len * 3) / 4\n\n  if (base64[base64.length - 1] === '~') {\n    bufferLength--\n    if (base64[base64.length - 2] === '~') {\n      bufferLength--\n    }\n  }\n\n  const arraybuffer = new ArrayBuffer(bufferLength)\n  const bytes = new Uint8Array(arraybuffer)\n\n  let encoded1: number\n  let encoded2: number\n  let encoded3: number\n  let encoded4: number\n  let p = 0\n\n  for (let i = 0; i < len; i += 4) {\n    encoded1 = lookup[base64.charCodeAt(i)]\n    encoded2 = lookup[base64.charCodeAt(i + 1)]\n    encoded3 = lookup[base64.charCodeAt(i + 2)]\n    encoded4 = lookup[base64.charCodeAt(i + 3)]\n\n    bytes[p++] = (encoded1 << 2) | (encoded2 >> 4)\n    bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2)\n    bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63)\n  }\n\n  return arraybuffer\n}\n", "// Browser and server\nconst { CompressionStream, DecompressionStream, Response } = globalThis\n\nexport type CompressionFormat = 'gzip' | 'deflate' | 'deflate-raw'\n\nexport const defaultCompressionFormat = 'gzip'\n\nexport async function compress(\n  data: string | ArrayBuffer,\n  compressionFormat: CompressionFormat = defaultCompressionFormat,\n): Promise<ArrayBuffer> {\n  const compressor = new CompressionStream(compressionFormat)\n  const stream = new Response(data).body?.pipeThrough(compressor)\n  return await new Response(stream).arrayBuffer()\n}\n\nasync function decompressAsResponse(\n  bytes: ArrayBuffer,\n  compressionFormat: CompressionFormat = defaultCompressionFormat,\n): Promise<Response> {\n  const decompressor = new DecompressionStream(compressionFormat)\n  const stream = new Response(bytes).body?.pipeThrough(decompressor)\n  return new Response(stream)\n}\n\nexport async function decompressAsArrayBuffer(\n  bytes: ArrayBuffer,\n  compressionFormat: CompressionFormat = defaultCompressionFormat,\n): Promise<ArrayBuffer> {\n  return (await decompressAsResponse(bytes, compressionFormat)).arrayBuffer()\n}\n\nexport async function decompressAsString(\n  bytes: ArrayBuffer,\n  compressionFormat: CompressionFormat = defaultCompressionFormat,\n): Promise<string> {\n  return (await decompressAsResponse(bytes, compressionFormat)).text()\n}\n\nexport { decompressAsArrayBuffer as decompress }\n"],
  "mappings": "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",
  "names": ["src_exports", "__export", "decode", "decodeBinary", "encode", "encodeBinary", "chars", "encodeBase64Url", "arraybuffer", "bytes", "len", "base64", "i", "lookup", "decodeBase64Url", "bufferLength", "encoded1", "encoded2", "encoded3", "encoded4", "p", "CompressionStream", "DecompressionStream", "Response", "defaultCompressionFormat", "compress", "data", "compressionFormat", "compressor", "stream", "decompressAsResponse", "bytes", "decompressor", "decompressAsArrayBuffer", "decompressAsString", "encode", "value", "compressionFormat", "encodeBase64Url", "compress", "decode", "text", "decompressAsString", "decodeBase64Url", "encodeBinary", "decodeBinary", "decompressAsArrayBuffer"]
}
